/**
 * CLI: generate artifacts. Requires --out-dir or --to.
 * Example: pnpm --filter @ssv/schemas generate --out-dir packages/frontend/src
 */

import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";
import { buildGroupMetaSchemaFromGroup } from "./groupMetaSchema.js";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PACKAGE_ROOT = path.resolve(__dirname, "..");

function findRepoRoot(start: string): string {
  let dir = start;
  for (;;) {
    if (fs.existsSync(path.join(dir, "pnpm-workspace.yaml"))) return dir;
    const parent = path.dirname(dir);
    if (parent === dir) return process.cwd();
    dir = parent;
  }
}

const REPO_ROOT = findRepoRoot(PACKAGE_ROOT);
const DATA_PATH = path.join(PACKAGE_ROOT, "data", "schema_rule_sets.json");
const DRAFT_07_META_PATH = path.join(PACKAGE_ROOT, "data", "draft-07-meta-schema.json");

const USAGE = `
Usage: generate --out-dir <path>   (or --to <path>)

  --out-dir <path>   Directory to write generated artifacts. Required.
  --to <path>        Alias for --out-dir.

Writes under the given path:
  - data/schema_rule_sets.generated.json
  - types/schemaRuleSets.generated.ts
  - data/rule-set-meta-schemas/<ruleSetId>.generated.json   (one meta-schema per rule set)
`;

function parseArgs(): string | null {
  const args = process.argv.slice(2);
  for (let i = 0; i < args.length; i++) {
    if ((args[i] === "--out-dir" || args[i] === "--to") && args[i + 1]) {
      return path.resolve(REPO_ROOT, args[i + 1]);
    }
  }
  return null;
}

function main(): void {
  const outDir = parseArgs();
  if (!outDir) {
    console.error(USAGE);
    process.exit(1);
  }

  if (!fs.existsSync(DATA_PATH)) {
    console.error(`Data not found: ${DATA_PATH}`);
    process.exit(1);
  }

  const ruleSetsJson = fs.readFileSync(DATA_PATH, "utf-8");
  const data = JSON.parse(ruleSetsJson) as { ruleSets: Array<{ ruleSetId: string; [key: string]: unknown }> };
  const typesPath = path.join(__dirname, "types-template.ts");
  const typesContent = fs.readFileSync(typesPath, "utf-8");
  const generatedTypesContent = typesContent.replace(
    "Generated from @ssv/schemas. Do not edit by hand.",
    "Generated by @ssv/schemas. Do not edit by hand."
  );

  const dataDir = path.join(outDir, "data");
  const typesDir = path.join(outDir, "types");
  fs.mkdirSync(dataDir, { recursive: true });
  fs.mkdirSync(typesDir, { recursive: true });

  const jsonOutPath = path.join(dataDir, "schema_rule_sets.generated.json");
  const tsOutPath = path.join(typesDir, "schemaRuleSets.generated.ts");

  fs.writeFileSync(jsonOutPath, ruleSetsJson, "utf-8");
  fs.writeFileSync(tsOutPath, generatedTypesContent, "utf-8");

  console.log(`Wrote ${jsonOutPath}`);
  console.log(`Wrote ${tsOutPath}`);

  if (!fs.existsSync(DRAFT_07_META_PATH)) {
    console.error(`Draft-07 meta-schema not found: ${DRAFT_07_META_PATH}`);
    process.exit(1);
  }
  const baseMetaSchema = JSON.parse(fs.readFileSync(DRAFT_07_META_PATH, "utf-8")) as Record<string, unknown>;

  const metaSchemasDir = path.join(dataDir, "rule-set-meta-schemas");
  fs.mkdirSync(metaSchemasDir, { recursive: true });
  for (const ruleSet of data.ruleSets) {
    const metaSchema = buildGroupMetaSchemaFromGroup(baseMetaSchema, ruleSet);
    const metaSchemaPath = path.join(metaSchemasDir, `${ruleSet.ruleSetId}.generated.json`);
    fs.writeFileSync(metaSchemaPath, JSON.stringify(metaSchema, null, 2), "utf-8");
    console.log(`Wrote ${metaSchemaPath}`);
  }
}

main();
